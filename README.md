## Project-backend

Till min backend har jag valt att använda mig av sqlite3 som databas att spara diverse produkter i, i detta fallet spelaktier. Databasen ligger under db foldern och databasen i sig består av tre olika tables, användare med användardata, samt funds för medel till konto och sedan stocks för aktieinfo. Jag valde att använda mig av sqlite3 då jag gillar hur smidigt det har fungerat under tidigare kursmoment, samt att det är otroligt smidigt att via terminalen kunna använda sqlite3 genom att köra sqlite3 mot texts.sqlite. Jag kan sedan göra olika statements direkt mot databasen vid felsökande för att sen dubbelkolla att rätt data har satts in osv. Precis som i min frontend har jag valt att dela upp mina filera i olika mappar för en tydligare struktur. Mina produkter ligger i produktmappen, och mina databas funktioner ligger under mappen models. Det blir mycket bättre tycker jag ifall man kör på konceptet att var sak har sin plats. 

För att ta mig till implementationen av min backend så återanvände jag mig av en hel del kod från tidigare kursmoment, något som även tipsades om i föreläsningsvideon kring projektet. Motivationen till att jag valde att göra det är väl att det har fungerat så pass väl kursmomenten innan projektet samt att jag då kan lägga fokus på andra delar av projektet, såsom en ordentligt implementation av att grafiskt rita ut aktiepriser i realtid. När jag ändå är inne på det så kan jag väl förklara hur jag har implementerat grafen rent tekniskt sätt på min backend. Jag har i min frontend-repo README förklarat hur jag connectar min socket mot backenden och hur jag via min React funktion 'componentDidMount()' först connectar: this.socket.on("connect") för att sedan emitta: this.socket.emit("set game", (game)) (utförligare beskrivning kring den frontend funktionaliteten finns som sagt i frontend repot). När backenden får den "set game" emitten med 'game' variabeln så filtrerar jag igenom mina produkter i products foldern tills jag har hittat produkten som matchar variabeln som jag skickat med. När jag hittat rätt produkt så sätter jag sedan en interval på 5 sekunder. Denna interval kommer var femte sekund att emitta tillbaks till frontenden med hjälp av io.emit("message", game) information om 'game', framförallt priset. Innan den emitten görs har jag dock ändrat priset med hjälp av en Wiener-process för att simuluera ett slags "real-world" scenario där priserna ändras i realtid. Det nya priset sätts först och skickas sedan ut med hjälp av tidigare nämnda io.emit.  
            

**Avslutande ord**

Utöver implementationen av att simulera ett "real-world" scenario där priserna ändras i realtid och för att sedan emitta den datan till frontenden så är sturkturen rätt snarlik tidigare kursmoment. Jag har som tagit till mig tipset att återanvända kod som jag skrivit i tidigare kursmoment så att jag kan lägga fokus på implementationen av nya grejor, vilket i det här fallet var till stor del implementationen av grafen. Det har varit kul att lära mig nya koncept så som Wiener-processen. Vidare så kommer jag i min föreläsningsvideo visa hur implementationen ser ut på min driftsatta sida och jar jag missat något här så kompletterar jag  med det i min redovisningstext på canvas. 
